  
  [1X1 [33X[0;0YIntroduction[133X[101X
  
  [33X[0;0YThis  chapter  serves  as  an  introduction  to  the package [5XProgressBar[105X and
  includes many examples.[133X
  
  [33X[0;0YThe  main purpose of this package is to display the progression of a process
  in  the  terminal via a progress bar that refreshes in the screen after each
  step of the process.[133X
  
  [33X[0;0YInstead  of  writing  new  lines in the terminal screen after each step of a
  process,  the  terminal  screen  gets  refreshed  in  space.  This method of
  displaying  information  avoids  spamming  in  the terminal, and provides an
  intuitive and clean visualization of the progress.[133X
  
  
  [1X1.1 [33X[0;0YExample: Loop[133X[101X
  
  [33X[0;0YIn  the  first  example we show the simplest use case of the package, namely
  displaying the progression of a loop over a fixed list.[133X
  
  [33X[0;0YFor this we simply wrap the list into the function [10XProcessIterator[110X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage("ProgressBar");;[127X[104X
    [4X[25Xgap>[125X [27XdoLoop := function(n, nSleep)[127X[104X
    [4X[25X>[125X [27X     local i;[127X[104X
    [4X[25X>[125X [27X     for i in ProcessIterator([1 .. n]) do[127X[104X
    [4X[25X>[125X [27X       MicroSleep(nSleep);[127X[104X
    [4X[25X>[125X [27X     od;[127X[104X
    [4X[25X>[125X [27X   end;;[127X[104X
    [4X[25Xgap>[125X [27XdoLoop(7, 10^6/4);;[127X[104X
  [4X[32X[104X
  
  [33X[0;0YIn  the  above  example  we might encounter the following outputs during the
  execution  of the iteration. All these outputs are visible in the same lines
  of the terminal for roughly 1/4 of a second.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[28X| Total Time ~ 00:00:00[128X[104X
    [4X[28X[========================================-------------------------------] | 4/7[128X[104X
    [4X[28X[128X[104X
    [4X[28X| Total Time ~ 00:00:01[128X[104X
    [4X[28X[=======================================================================] | 7/7[128X[104X
  [4X[32X[104X
  
  [33X[0;0YThe package can also handle very fast updates, but keep in mind that it adds
  some  overhead  to the computation. In this example, the overhead acumulates
  over  the  [22X5000[122X  iterations  to [22X2[122X extra seconds for a computation that would
  otherwise only take about [22X5[122X seconds.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage("ProgressBar");;[127X[104X
    [4X[25Xgap>[125X [27XdoLoop := function(n, nSleep)[127X[104X
    [4X[25X>[125X [27X     local i;[127X[104X
    [4X[25X>[125X [27X     for i in ProcessIterator([1 .. n]) do[127X[104X
    [4X[25X>[125X [27X       MicroSleep(nSleep);[127X[104X
    [4X[25X>[125X [27X     od;[127X[104X
    [4X[25X>[125X [27X   end;;[127X[104X
    [4X[25Xgap>[125X [27XdoLoop(5000, 1000);[127X[104X
  [4X[32X[104X
  
  
  [1X1.2 [33X[0;0YExample: Indefinite Loop[133X[101X
  
  [33X[0;0YWe can also display the progression of an indefinite loop.[133X
  
  [33X[0;0YFor this we simply wrap an iterator into the function [10XProcessIterator[110X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage("ProgressBar");;[127X[104X
    [4X[25Xgap>[125X [27XdoLoop := function(n, nSleep)[127X[104X
    [4X[25X>[125X [27X     local i;[127X[104X
    [4X[25X>[125X [27X     for i in ProcessIterator(IteratorOfCombinations([1 .. n])) do[127X[104X
    [4X[25X>[125X [27X       MicroSleep(nSleep);[127X[104X
    [4X[25X>[125X [27X     od;[127X[104X
    [4X[25X>[125X [27X   end;;[127X[104X
    [4X[25Xgap>[125X [27XdoLoop(8, 10^4);;[127X[104X
  [4X[32X[104X
  
  [33X[0;0YIn  the  above  example  we might encounter the following outputs during the
  execution of the iteration.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[28X| Total Time ~ 00:00:01[128X[104X
    [4X[28X[--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--=] | 123/oo[128X[104X
    [4X[28X[128X[104X
    [4X[28X| Total Time ~ 00:00:02[128X[104X
    [4X[28X[==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==-] | 193/oo[128X[104X
    [4X[28X[128X[104X
    [4X[28X| Total Time ~ 00:00:03[128X[104X
    [4X[28X[===================================================================] | 256/oo[128X[104X
  [4X[32X[104X
  
  [33X[0;0YSometimes we can actually compute the number of steps needed for the process
  to  terminate  beforehand.  This  will  change  the display and provide more
  detailed information about the progress, see [14X1.1[114X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage("ProgressBar");;[127X[104X
    [4X[25Xgap>[125X [27XdoLoop := function(n, nSleep)[127X[104X
    [4X[25X>[125X [27X     local iter, i;[127X[104X
    [4X[25X>[125X [27X     iter := ProcessIterator(rec([127X[104X
    [4X[25X>[125X [27X       iter := IteratorOfCombinations([1 .. n]),[127X[104X
    [4X[25X>[125X [27X       totalSteps := 2^n[127X[104X
    [4X[25X>[125X [27X     ));[127X[104X
    [4X[25X>[125X [27X     for i in iter do[127X[104X
    [4X[25X>[125X [27X       MicroSleep(nSleep);[127X[104X
    [4X[25X>[125X [27X     od;[127X[104X
    [4X[25X>[125X [27X   end;;[127X[104X
    [4X[25Xgap>[125X [27XdoLoop(8, 10^4);;[127X[104X
  [4X[32X[104X
  
  [33X[0;0YIf  we  set  the  [10XtotalSteps[110X wrong, the display will change to an indefinite
  loop once we exceed them in the iteration.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage("ProgressBar");;[127X[104X
    [4X[25Xgap>[125X [27XdoLoop := function(n, nSleep)[127X[104X
    [4X[25X>[125X [27X     local iter, i;[127X[104X
    [4X[25X>[125X [27X     iter := ProcessIterator(rec([127X[104X
    [4X[25X>[125X [27X       iter := IteratorOfCombinations([1 .. n]),[127X[104X
    [4X[25X>[125X [27X       totalSteps := 2^(n-1)[127X[104X
    [4X[25X>[125X [27X     ));[127X[104X
    [4X[25X>[125X [27X     for i in iter do[127X[104X
    [4X[25X>[125X [27X       MicroSleep(nSleep);[127X[104X
    [4X[25X>[125X [27X     od;[127X[104X
    [4X[25X>[125X [27X   end;;[127X[104X
    [4X[25Xgap>[125X [27XdoLoop(8, 10^4);;[127X[104X
  [4X[32X[104X
  
  
  [1X1.3 [33X[0;0YExample: Printing Values[133X[101X
  
  [33X[0;0YIf we want to print the value of the current iteration, this can be done via
  an optional content record.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage("ProgressBar");;[127X[104X
    [4X[25Xgap>[125X [27XdoLoopWithValue := function(n, nSleep)[127X[104X
    [4X[25X>[125X [27X     local i, j;[127X[104X
    [4X[25X>[125X [27X     for i in ProcessIterator([1 .. n], rec([127X[104X
    [4X[25X>[125X [27X         title := JoinStringsWithSeparator([[127X[104X
    [4X[25X>[125X [27X           "---------------",[127X[104X
    [4X[25X>[125X [27X           "Main iteration:",[127X[104X
    [4X[25X>[125X [27X           "  j = {{value + 100}}",[127X[104X
    [4X[25X>[125X [27X         ], "\n"))) do[127X[104X
    [4X[25X>[125X [27X       j := i + 100;[127X[104X
    [4X[25X>[125X [27X       MicroSleep(nSleep);[127X[104X
    [4X[25X>[125X [27X     od;[127X[104X
    [4X[25X>[125X [27X   end;;[127X[104X
    [4X[25Xgap>[125X [27XdoLoopWithValue(35, 10^6/10);;[127X[104X
  [4X[32X[104X
  
  
  [1X1.4 [33X[0;0YExample: Nested Loop[133X[101X
  
  [33X[0;0YThe package also supports displaying nested loops.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage("ProgressBar");;[127X[104X
    [4X[25Xgap>[125X [27XdoNestedLoop := function(n, nSleep, m, mSleep)[127X[104X
    [4X[25X>[125X [27X     local i, j;[127X[104X
    [4X[25X>[125X [27X     for i in ProcessIterator([1 .. n]) do[127X[104X
    [4X[25X>[125X [27X       MicroSleep(nSleep);[127X[104X
    [4X[25X>[125X [27X       for j in ProcessIterator([1 .. m]) do[127X[104X
    [4X[25X>[125X [27X         MicroSleep(mSleep);[127X[104X
    [4X[25X>[125X [27X       od;[127X[104X
    [4X[25X>[125X [27X     od;[127X[104X
    [4X[25X>[125X [27X   end;;[127X[104X
    [4X[25Xgap>[125X [27XdoNestedLoop(3, 10^6/2, 50, 10^4);;[127X[104X
  [4X[32X[104X
  
  [33X[0;0YAn example output might look like this[133X
  
  [4X[32X  Example  [32X[104X
    [4X[28X| Total Time ~ 00:00:01[128X[104X
    [4X[28X[==============================================-----------------------] |  2/ 3[128X[104X
    [4X[28X   [------------------------------------------------------------------] |  0/50[128X[104X
    [4X[28X[128X[104X
    [4X[28X| Total Time ~ 00:00:02[128X[104X
    [4X[28X[==============================================-----------------------] |  2/ 3[128X[104X
    [4X[28X   [===============================================-------------------] | 36/50[128X[104X
    [4X[28X[128X[104X
    [4X[28X| Total Time ~ 00:00:02[128X[104X
    [4X[28X[=====================================================================] |  3/ 3[128X[104X
    [4X[28X   [==================================================================] | 50/50[128X[104X
  [4X[32X[104X
  
  
  [1X1.5 [33X[0;0YExample: Tree[133X[101X
  
  [33X[0;0YWe  can also display much more intertwined processes than nested loops. This
  package can handle any process tree.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage("ProgressBar");;[127X[104X
    [4X[25Xgap>[125X [27XdoTree := function(n, nSleep, l, lSleep, m, mSleep, r, rSleep)[127X[104X
    [4X[25X>[125X [27X     local i, j, k;[127X[104X
    [4X[25X>[125X [27X     for i in ProcessIterator([1 .. n]) do[127X[104X
    [4X[25X>[125X [27X       MicroSleep(nSleep);[127X[104X
    [4X[25X>[125X [27X       for j in ProcessIterator([1 .. l]) do[127X[104X
    [4X[25X>[125X [27X         MicroSleep(lSleep);[127X[104X
    [4X[25X>[125X [27X         for k in ProcessIterator([1 .. m]) do[127X[104X
    [4X[25X>[125X [27X           MicroSleep(mSleep);[127X[104X
    [4X[25X>[125X [27X         od;[127X[104X
    [4X[25X>[125X [27X       od;[127X[104X
    [4X[25X>[125X [27X       for j in ProcessIterator([1 .. r]) do[127X[104X
    [4X[25X>[125X [27X         MicroSleep(rSleep);[127X[104X
    [4X[25X>[125X [27X       od;[127X[104X
    [4X[25X>[125X [27X     od;[127X[104X
    [4X[25X>[125X [27X   end;;[127X[104X
    [4X[25Xgap>[125X [27XdoTree(3, 10^6/10, 5, 10^6/2, 4, 10^6/10, 12, 10^6/10);;[127X[104X
  [4X[32X[104X
  
  [33X[0;0YExample output during the execution of the function:[133X
  
  [4X[32X  Example  [32X[104X
    [4X[28X| Total Time ~ 00:00:15[128X[104X
    [4X[28X[==============================================-----------------------] |  2/ 3[128X[104X
    [4X[28X   [=======================================---------------------------] |  3/ 5[128X[104X
    [4X[28X   |  [===============================--------------------------------] |  2/ 4[128X[104X
    [4X[28X   [------------------------------------------------------------------] |  0/12[128X[104X
  [4X[32X[104X
  
  [33X[0;0YIn  the above example we create the processes on the fly, so for example the
  [21XRight[121X  process appears in the terminal only after we create this process for
  the  first  time.  When  this  happens,  the  layout  of the display changes
  slightly,  because  the  total  number of iterations for [21XRight[121X has 2 digits,
  whereas  for  each  of  the  ones before that it had 1 digit. Example output
  before process [21XRight[121X gets created for the first time:[133X
  
  [4X[32X  Example  [32X[104X
    [4X[28X| Total Time ~ 00:00:03[128X[104X
    [4X[28X[-----------------------------------------------------------------------] | 0/3[128X[104X
    [4X[28X   [======================================================--------------] | 4/5[128X[104X
    [4X[28X      [-----------------------------------------------------------------] | 0/4[128X[104X
  [4X[32X[104X
  
  [33X[0;0YExample output after process [21XRight[121X gets created for the first time:[133X
  
  [4X[32X  Example  [32X[104X
    [4X[28X| Total Time ~ 00:00:11[128X[104X
    [4X[28X[=======================----------------------------------------------] |  1/ 3[128X[104X
    [4X[28X   [==================================================================] |  5/ 5[128X[104X
    [4X[28X   |  [===============================================================] |  4/ 4[128X[104X
    [4X[28X   [======================================----------------------------] |  7/12[128X[104X
  [4X[32X[104X
  
  [33X[0;0YIf  we  want  to  see  all  processes from the beginning, we need to set the
  processes before the most outer loop starts.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage("ProgressBar");;[127X[104X
    [4X[25Xgap>[125X [27XdoTree := function(n, nSleep, l, lSleep, m, mSleep, r, rSleep)[127X[104X
    [4X[25X>[125X [27X     local iter, i, j, k;[127X[104X
    [4X[25X>[125X [27X     iter := ProcessIterator([1 .. n], "Root", fail);[127X[104X
    [4X[25X>[125X [27X     SetProcess(l, "Left", "Root");[127X[104X
    [4X[25X>[125X [27X     SetProcess(m, "Inner", "Left");[127X[104X
    [4X[25X>[125X [27X     SetProcess(r, "Right", "Root");[127X[104X
    [4X[25X>[125X [27X     for i in iter do[127X[104X
    [4X[25X>[125X [27X       MicroSleep(nSleep);[127X[104X
    [4X[25X>[125X [27X       for j in ProcessIterator([1 .. l], "Left", "Root") do[127X[104X
    [4X[25X>[125X [27X         MicroSleep(lSleep);[127X[104X
    [4X[25X>[125X [27X         for k in ProcessIterator([1 .. m], "Inner", "Left") do[127X[104X
    [4X[25X>[125X [27X           MicroSleep(mSleep);[127X[104X
    [4X[25X>[125X [27X         od;[127X[104X
    [4X[25X>[125X [27X       od;[127X[104X
    [4X[25X>[125X [27X       for j in ProcessIterator([1 .. r], "Right", "Root") do[127X[104X
    [4X[25X>[125X [27X         MicroSleep(rSleep);[127X[104X
    [4X[25X>[125X [27X       od;[127X[104X
    [4X[25X>[125X [27X     od;[127X[104X
    [4X[25X>[125X [27X   end;;[127X[104X
    [4X[25Xgap>[125X [27XdoTree(3, 10^6/10, 5, 10^6/2, 4, 10^6/10, 12, 10^6/10);;[127X[104X
  [4X[32X[104X
  
  [33X[0;0YThen the output looks like this from the start:[133X
  
  [4X[32X  Example  [32X[104X
    [4X[28X| Total Time ~ 00:00:03[128X[104X
    [4X[28X[---------------------------------------------------------------------] |  0/ 3[128X[104X
    [4X[28X   [=======================================---------------------------] |  3/ 5[128X[104X
    [4X[28X   |  [---------------------------------------------------------------] |  0/ 4[128X[104X
    [4X[28X   [------------------------------------------------------------------] |  0/12[128X[104X
  [4X[32X[104X
  
  
  [1X1.6 [33X[0;0YExample: Table[133X[101X
  
  [33X[0;0YIf for example we want to compare the performance of different processes, it
  might be more intuitive to switch to the table layout.[133X
  
  [33X[0;0YFor  this  we  need to define a dummy process, that we terminate manually in
  the  end.  All  processes we want to track have to be defined as children of
  this dummy.[133X
  
  [33X[0;0YTODO[133X
  
  
  [1X1.7 [33X[0;0YExample: Stopping[133X[101X
  
  [33X[0;0YIf  there  is  code  that we do not want to track in our process, we can use
  [10XStopProcess[110X and [10XStartProcess[110X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLoadPackage("ProgressBar");;[127X[104X
    [4X[25Xgap>[125X [27XdoLoopWithStop := function(n, nSleep, mSleep)[127X[104X
    [4X[25X>[125X [27X     local i;[127X[104X
    [4X[25X>[125X [27X     for i in ProcessIterator([1 .. n], "proc") do[127X[104X
    [4X[25X>[125X [27X       MicroSleep(nSleep);[127X[104X
    [4X[25X>[125X [27X       StopProcess("proc");[127X[104X
    [4X[25X>[125X [27X       MicroSleep(mSleep);[127X[104X
    [4X[25X>[125X [27X       StartProcess("proc");[127X[104X
    [4X[25X>[125X [27X     od;[127X[104X
    [4X[25X>[125X [27X   end;;[127X[104X
    [4X[25Xgap>[125X [27XdoLoopWithStop(50, 10^6/10, 10^6/10);;[127X[104X
  [4X[32X[104X
  
  [33X[0;0YIn  the  above example the code runs for roughly 10 seconds, but the tracked
  total time that contributes to the process shows roughly 5 seconds.[133X
  
