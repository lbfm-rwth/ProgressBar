<!--===========================================================================
||||  Introduction                                                         ||||
===============================================================================
||||  This file is part of the ProgressBar package.
||||
||||  This file's authors include Friedrich Rober.
||||
||||  Please refer to the COPYRIGHT file for details.
||||
||||  SPDX-License-Identifier: GPL-2.0-or-later
===============================================================================
============================================================================-->


<Chapter Label="Intro">
<Heading>Introduction</Heading>

This chapter serves as an introduction to the package &ProgressBar; and includes many examples. <P/>

The main purpose of this package is to display the progression of a process in the terminal
via a progress bar that refreshes in the screen after each step of the process. <P/>

Instead of writing new lines in the terminal screen after each step of a process,
the terminal screen gets refreshed in space.
This method of displaying information avoids spamming in the terminal,
and provides an intuitive and clean visualization of a progress.


<!--===========================================================================
||||  Example : Loop                                                       ||||
============================================================================-->


<Section Label="Intro Loop Example">
<Heading>Example: Loop</Heading>

In the first example we show the simplest use case of the package,
namely displaying the progression of a loop. <P/>

For this we simply wrap an iterator into the function <C>ProcessIterator</C>.

<Example><![CDATA[
gap> LoadPackage("ProgressBar");;
gap> doLoop := function(n, nSleep)
>      local i;
>      for i in ProcessIterator([1 .. n]) do
>        MicroSleep(nSleep);
>      od;
>    end;;
gap> doLoop(7, 10^6/4);
 [===================================================] 100% | 7/7 | eta 0:00:00
]]></Example>

In the above example we might encounter the following outputs during the execution of the iteration.
All these outputs are visible in the same line of the terminal for roughly 1/4 of a second.
<Example><![CDATA[
 [=======--------------------------------------------]  14% | 1/7 | eta 0:00:06
 [=====================------------------------------]  42% | 3/7 | eta 0:00:04
 [====================================---------------]  71% | 5/7 | eta 0:00:02
 [===================================================] 100% | 7/7 | eta 0:00:00
]]></Example>

TODO:
The package can also handle very fast updates,
but keep in mind that it adds some overhead to the computation.
In this example, the overhead acumulates over the TODO iterations to TODO extra seconds
for a computation that would otherwise only take about TODO seconds.

<Example><![CDATA[
gap> LoadPackage("ProgressBar");;
gap> SetDisplayOptionsOfProgressPrinter(rec(printTotalTime := true));;
gap> doLoop(5000, 1000);;
gap> ResetDisplayOptionsOfProgressPrinter();;
]]></Example>

</Section>


<!--===========================================================================
||||  Example : Nested Loop                                                ||||
============================================================================-->


<Section Label="Intro Nested Loop Example">
<Heading>Example: Nested Loop</Heading>

The package also supports displaying nested loops.
For this we need to specify the parent-child relationships of the individual processes.
We also adjust the display to show the total execution time of the root process.
<Example><![CDATA[
gap> LoadPackage("ProgressBar");;
gap> doNestedLoop := function(n, nSleep, m, mSleep)
>      local i, j;
>      for i in ProcessIterator([1 .. n], "1") do
>        MicroSleep(nSleep);
>        for j in ProcessIterator([1 .. m], "2", "1") do
>          MicroSleep(mSleep);
>        od;
>      od;
>    end;;
gap> SetDisplayOptionsOfProgressPrinter(rec(printTotalTime := true));
gap> doNestedLoop(3, 10^6/2, 50, 10^4);

]]></Example>

An example output might look like this
<Example><![CDATA[

]]></Example>

</Section>


<!--===========================================================================
||||  Example : Process with Steps                                         ||||
============================================================================-->


<Section Label="Intro Process Steps Example">
<Heading>Example: Process with Steps</Heading>

Apart from displaying loops, the package can be used to display the progress during the execution of a function as well.
<Example><![CDATA[
gap> LoadPackage("ProgressBar");;
gap> doSteps := function()
>      local proc, opts;
>      proc := SetProcess(3);;
>      UpdateProcess(proc, rec(header := "Doing Step 1"));
>      Sleep(2);
>      UpdateProcess(proc, rec(header := "Doing Step 2"));
>      Sleep(4);
>      UpdateProcess(proc, rec(header := "Doing Step 3"));
>      Sleep(2);
>      UpdateProcess(proc, rec(header := "Finished"));
>    end;;
gap> doSteps();
 | Finished
 [=================================================================] 100% | 3/3
]]></Example>

In the above example we would see the following outputs before the termination of the process,
each displayed in the same lines of the screen.
<Example><![CDATA[
 | Doing Step 1
 [-----------------------------------------------------------------]   0% | 0/3

 | Doing Step 2
 [=====================--------------------------------------------]  33% | 1/3

 | Doing Step 3
 [===========================================----------------------]  66% | 2/3
]]></Example>

</Section>


<!--===========================================================================
||||  Example : Tree                                                       ||||
============================================================================-->


<Section Label="Intro Tree Example">
<Heading>Example: Tree</Heading>

We can also display much more intertwined processes than nested loops.
This package can handle any process tree. <P/>

<Example><![CDATA[
gap> LoadPackage("ProgressBar");;
gap> doTree := function(n, nSleep, l, lSleep, m, mSleep, r, rSleep)
>      local i, j, k;
>      for i in ProcessIterator([1 .. n], "Root", fail) do
>        MicroSleep(nSleep);
>        for j in ProcessIterator([1 .. l], "Left", "Root") do
>          MicroSleep(lSleep);
>          for k in ProcessIterator([1 .. m], "Inner", "Left") do
>            MicroSleep(mSleep);
>          od;
>        od;
>        for j in ProcessIterator([1 .. r], "Right", "Root") do
>          MicroSleep(rSleep);
>        od;
>      od;
>    end;;
gap> SetDisplayOptionsOfProgressPrinter(rec(
>      printID := true,
>      printTotalTime := true,
>      highlightCurStep := true,
>    ));;
gap> doTree(3, 10^6/10, 5, 10^6/2, 4, 10^6/10, 12, 10^6/10);
]]></Example>

Example output during the execution of the function:
<Example><![CDATA[
 | Total Time 0:00:42
 | Root
 [=================----------------------------------]  33% | 1/3 | eta 0:00:43
    | Left
    [================================================] 100% | 5/5 | eta 0:00:00
    |  | Inner
    |  [---------------------------------------------]   0% | 0/2 | eta ?:??:??
    | Right
    [====================================------------]  75% | 3/4 | eta 0:00:01
]]></Example>

In the above example we create the processes on the fly,
so for example the <Q>Right</Q> process appears in the terminal only after we create this process for the first time.
When this happens, the layout of the display changes slightly, because the total number of iterations for <Q>Right</Q> has 2 digits,
whereas for each of the ones before that it had 1 digit.
If we want to see all processes from the beginning, we need to set the processes before the most outer loop starts.
<Example><![CDATA[
gap> LoadPackage("ProgressBar");;
gap> doTree := function(n, nSleep, l, lSleep, m, mSleep, r, rSleep)
>      local iter, i, j, k;
>      iter := ProcessIterator([1 .. n], "Root", fail);
>      SetProcess(l, "Left", "Root");
>      SetProcess(m, "Inner", "Left");
>      SetProcess(r, "Right", "Root");
>      for i in iter do
>        MicroSleep(nSleep);
>        for j in ProcessIterator([1 .. l], "Left", "Root") do
>          MicroSleep(lSleep);
>          for k in ProcessIterator([1 .. m], "Inner", "Left") do
>            MicroSleep(mSleep);
>          od;
>        od;
>        for j in ProcessIterator([1 .. r], "Right", "Root") do
>          MicroSleep(rSleep);
>        od;
>      od;
>    end;;
gap> doTree(3, 10^6/10, 5, 10^6/2, 4, 10^6/10, 12, 10^6/10);
]]></Example>
</Section>


<!--===========================================================================
============================================================================-->


</Chapter>
